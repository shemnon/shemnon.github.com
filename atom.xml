<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[...and they shall know me by my speling errors.]]></title>
  <link href="http://speling.shemnon.com//atom.xml" rel="self"/>
  <link href="http://speling.shemnon.com//"/>
  <updated>2012-10-10T04:39:52-06:00</updated>
  <id>http://speling.shemnon.com//</id>
  <author>
    <name><![CDATA[Danno Ferrin]]></name>
    <email><![CDATA[danno.ferrin@shemnon.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Mirroring OpenJFX on BitBucket]]></title>
    <link href="http://speling.shemnon.com//blog/2012/10/09/mirroring-openjfx-on-bitbucket/"/>
    <updated>2012-10-09T21:16:00-06:00</updated>
    <id>http://speling.shemnon.com//blog/2012/10/09/mirroring-openjfx-on-bitbucket</id>
    <content type="html"><![CDATA[<p>I&#8217;ve started mirroring the OpenJFX repositories over at <a href="http://bitbucket.org/shemnon/">bitbucket</a>.  Viewing the repos on bitbucket has several advantages:</p>

<ol>
<li>It has an easier on the eyes user interface.  Really, I could stop here.</li>
<li>The push request mechanism encourages social coding</li>
<li>It has a code review feature</li>
</ol>


<p>This last point is the most recent one.  You can comment on commits and comment at specific lines in the commit.  Useful when you have to send a pull request back.</p>

<h2>Repos</h2>

<p>As for the repositories I have four repos right now.</p>

<!-- more -->


<p>The first three are direct mirrors of their <code>rt</code> counterparts in the JavaFX portion of the <a href="http://hg.openjdk.java.net/">official OpenJDK Mercurial repository</a>.</p>

<ul>
<li><a href="http://hg.openjdk.java.net/openjfx/8/master/rt/">master/rt</a> -> <a href="https://bitbucket.org/shemnon/openjfx-8-rt-master-branch">openjfx-rt-master-branch</a></li>
<li><a href="http://hg.openjdk.java.net/openjfx/8/controls/rt/">controls/rt</a> -> <a href="https://bitbucket.org/shemnon/openjfx-8-rt-controls-branch">openjfx-rt-controls-branch</a></li>
<li><a href="http://hg.openjdk.java.net/openjfx/8/graphics/rt/">graphics/rt</a> -> <a href="https://bitbucket.org/shemnon/openjfx-8-rt-graphics-branch">openjfx-rt-graphics-branch</a></li>
</ul>


<p>I am not mirroring the parent repo nor the <code>test</code> repo.  The parent repo is just a holder for the <code>rt</code> repo and (presumed) binary repos.  The <code>test</code> repo contains jemmy and a smoke test driven off of ensemble, i.e. parts needed for a professional build but not needed for the casual hack.  The casual hack is why I am doing this.</p>

<p>The fourth repo is my <a href="https://bitbucket.org/shemnon/openjfx-rt/">openfx-rt</a> repo.  This is a merger of the three previous repos.  Instead of keeping a branch for each I am pushing the bookmark for <code>controls</code>, <code>graphics</code>, and <code>master</code> to match the current tip of each of the real repos.  Bookmarks in Mercurial are more like branches in Git, just pointers to a change list.  Branches in mercurial embed themselves in the commit message, so you cannot retroactively create them without rewriting history.</p>

<p>This is also the repo where I do my hacks.  Look for the stray tips.</p>

<h2>Builds</h2>

<p>Also, as best as I can tell the open source build is currently broken.  The instructions pre-date the JRE integration of JavaFX, and also predate the addition of some of the more interesting sub projects, like FXML.  So to fix that I threw together some Gradle builds <a href="https://bitbucket.org/shemnon/openjfx-rt/changeset/46b2f08c0a3cb40c12a1e67184ba0b05c70d5596">here</a> and <a href="https://bitbucket.org/shemnon/openjfx-rt/changeset/a5a78c8ed2c4f287d2525ddf2231ea05f3659a99">here</a> that will compile the code and the tests.  Some of the tests even run. To completion. Successfully.  But it doesn&#8217;t create a usable <code>jfxrt.jar</code> at the end.  Until the while kit and caboodle is released I don&#8217;t think it&#8217;s worth going that far.  i.e. not fit for production use.  But perfect for casual hacking.</p>

<p>To run it you need to either</p>

<ul>
<li>Run Gradle with a <a href="http://jdk8.java.net/download.html">current JDK8 build</a></li>
<li>Point the env var <code>JFXRT_HOME</code> to the directory <code>jfxrt.jar</code> lives from a <a href="http://jdk8.java.net/download.html">current JDK8 build</a> before running Gradle.</li>
</ul>


<p>Then do something like <code>gradle assemble</code>, <code>gradle test</code>, <code>gradle compileJava</code>, <code>gradle compileTest</code>.  Be careful with the <code>test</code> task, it will go into an infinite loop in <code>javafx-concurrent</code>, I&#8217;m sure I don&#8217;t have something set up right.</p>

<h2>Casual Hacking</h2>

<p>I did this to aid my casual hacking, or as I like to call it &#8220;random acts of coding.&#8221;  You will note that I hooked up the JIRA bugs to the <a href="http://javafx-jira.kenai.com/">OpenJFX bug database</a>, and that <a href="https://bitbucket.org/shemnon/openjfx-rt/changeset/ab6e4c5150e45a92391bd2bf4c6a78255c283535">my first random act of code</a> is hooked up to the <a href="http://javafx-jira.kenai.com/browse/RT-25559">associated JIRA</a>.  It is a feature request I tweeted to Jonathan Giles several months ago, and was too lazy to write up a JIRA specifying what I want. The problem was that it seemed like a long loop of (a) landing in someone&#8217;s bug queue then (b) they have the bandwidth to do it and (c) that they do it the way I intended it to work.  If (c) fails it is another giant loop with the jiras to iterate (a), (b), and (c) again.  That and I&#8217;ve always been the type of person who would rather jump in and do it. I do have to say thug, that this has been quite a bit of yak shaving for 10 lines of code. And my <a href="http://preshavedyak.com/">pre shaved yak hoodie</a> I got at JavaOne only helps me with web apps.</p>

<p>If we want to make OpenJFX more accessible to casual hacking then some of the barriers need to be removed.  A &#8216;blessed&#8217; repo on BitBucket would make sandbox hacking more accessible.  A build that requires nothing more that a current Java 8 build and the build tool installed would be another great step.  With this casual hackers could push changes and a quick yes/no/maybe on the hack could be said in the pull queue before they fire up a JIRA and make sure their contributor paperwork is in order. In my opinion a hack then shave the yak ordering will get a lot more interest than a shave the yak then hack ordering.</p>

<p>But all of this only holds for the Java portions of the build.  When it comes to the native libraries I really don&#8217;t think you can wander too far from your yak shaving shears.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fashion Forward: Styling your Controls in JavaFX 2.2]]></title>
    <link href="http://speling.shemnon.com//blog/2012/08/13/fashion-forward-styling-your-controls-in-javafx-2-dot-2/"/>
    <updated>2012-08-13T08:02:00-06:00</updated>
    <id>http://speling.shemnon.com//blog/2012/08/13/fashion-forward-styling-your-controls-in-javafx-2-dot-2</id>
    <content type="html"><![CDATA[<p>JavaFX is finally delivering on it&#8217;s promise (made 5 years) to open source JavaFX. It started last December with the controls code. And now that the <a href="http://hg.openjdk.java.net/openjfx/8/master/">JavaFX 8 repos</a> are open we can now look at the internals of JavaFX in a format much more readable than <code>javap</code> decompilations. (The previous statement is not an admission, wink wink nod nod).</p>


<p>One of the questions I had was how the CSS styles are used in a Node. And after looking at some of the innards I realized that I didn&#8217;t really care how JavaFX does it, I care about how I can get my control stylized like the built in controls. To demonstrate the CSS stylings, I created <code>DemoTwo</code> in my <a href="https://github.com/shemnon/DeckControl/">DeckControl</a> project, allowing you to customize the control via CSS. Only the shelf variants in this demo use the custom properties, the others are just using the built in <code>-fx-skin</code> style to do the switching.</p>




<!-- more -->




<p><strong>A Word of Warning</strong></p>


<p>These are all internal APIs, the kind that the java compiler ought to warn you about but doesn&#8217;t. These APIs will change before JavaFX 8 is released in some fashion (assuming that they can keep the schedule and get these APIs exposed properly). These changes may be as minor as package names but are likely to change in more substantive ways. So before you read further I want you to raise your right hand, place your left hand behind your back, cross your fingers, and swear to me that you will not whine, complain, or moan when Oracle changes things and ruins all your fun. Now pinky swear on it. Ok, now we can begin.</p>


<p><strong>Make Your Property Styleable</strong></p>


<p>First, you have to make the properties use the styleable types. The types you will want to use are the  <code>com.sun.javafx.css.Styleable&lt;Foo&gt;Property</code> classes. It&#8217;s not a find-and-replace option, you will need to use an inner class of some sort.The classes are abstract and three methods are not implemented: <code>getStyleableProperty()</code>, <code>getBean()</code>, and <code>getName()</code>. The first method <code>getStyleableProperty()</code> returns an instance of <code>StyleableProperty</code> that describes this property. We will discuss this more in the next section. The other two methods (<code>getBean()</code> and <code>getName()</code>) actually come from the <code>javafx.beans.properties.ReadOnlyProperties</code> interface, so their role is already a known quantity. You may also want to overload the <code>invalidated()</code> method, which at this point provides less overhead than attaching an invalidated listener.</p>


<p>There are also some stylistic concerns with extending the property. You may want to use some lazy loading of the property to make overriding easier to detect. You can also return a default value from the getter if the property is null, and only initialize the getter in the property method. Here is an example from my Deck class of the styleable property.</p>


<div><script src='https://gist.github.com/3711714.js?file=StyleableProperty1.java'></script>
<noscript><pre><code>    public final void setBackScale(double value) {
        backScaleProperty().set(value);
    }
    public final double getBackScale() {
        return backScale == null ? 0.7 : backScale.get();
    }

    public final DoubleProperty backScaleProperty() {
        if (backScale == null) {
            backScale = new StyleableDoubleProperty(0.7) {

                @Override
                protected void invalidated() {
                    styleablePropertyInvalidated();
                }

                @Override
                public StyleableProperty getStyleableProperty() {
                    return BACK_SCALE;
                }

                @Override
                public Object getBean() {
                    return ShelfDeckSkin.this;
                }

                @Override
                public String getName() {
                    return &quot;backScale&quot;;
                }
            };
        }
        return backScale;
    }
</code></pre></noscript></div>




<p><strong>Describe Your Styleable Property</strong></p>


<p>The next step is to describe your styleable property. It&#8217;s kind of chicken and egg with the property instance itself since you have to reference the description in the property and the description needs to know how to get the property.</p>


<p>All of these descriptions are of type <code>com.sun.javafx.css.StyleableProperty</code> and this class is (you guessed it) abstract. All of the concrete version of this class in the codebase I can find are all anonymous or implementation details.</p>


<p>The class is generically typed, with the first type <code>N</code> being the type of the <code>Node</code> you are creating the styleable property for, and the second type <code>V</code> being the type of the property in the Java code, such as Number or Boolean.</p>


<p>Since this is an abstract class and not an interface we have to deal with the parent constructor. The two required variables are the CSS name of the property and an object responsible for the conversions of the CSS strings to the real type. Do yourself a favor and just use one of the converters in <code>com.sun.javafx.css.convrrters</code>. There are constructors with more parameters, such as a default value, CSS inheritance flags, and information for marking the property as one that can be composed by other properties (such as font handling).  I would anticipate that the two or three argument constructors being the most useful ones.</p>


<p>The two methods you have to implement are <code>isSettable(N)</code> and <code>getWritableValue(N)</code>. The first method returns a boolean flag that tells the CSS engine if it should try and set the property from CSS or not. If you don&#8217;t want to set the property under some circumstances, like it is bound to some other properties value, you will return false. This is where the first type parameter comes into play, it doesn&#8217;t have to exactly be your type, but it will be the type of the parameter of this and the next method. The second method is where you return your property object from the previous section.  Since the declaration is shared among multiple controls, the particular instance is passed in as a parameter.</p>


<p>Remember, this object is more of a type declaration than the actual value of the property. We are telling the engine about the property and not becoming the property itself, that is what the previous section was about.</p>


<div><script src='https://gist.github.com/3711714.js?file=StyleableProperty2.java'></script>
<noscript><pre><code>    private static final StyleableProperty&lt;ShelfDeckSkin,Number&gt; BACK_SCALE =
            new StyleableProperty&lt;ShelfDeckSkin,Number&gt;(&quot;-x-back-scale&quot;,
                    SizeConverter.getInstance(), 0.7) {

                @Override
                public boolean isSettable(ShelfDeckSkin deck) {
                    return deck.backScale == null || !deck.backScale.isBound();
                }

                @Override
                public WritableValue&lt;Number&gt; getWritableValue(ShelfDeckSkin deck) {
                    return deck.backScaleProperty();
                }
            };
</code></pre></noscript></div>




<p><strong>Enumerate Your Styleable Property</strong></p>


<p>Finally we have to let the engine know about our CSS properties. The magic incantation in this case is to add a method <code>public List&lt;StyleableProperty&gt; impl_getStyleableProperties()</code> to your control class. Note that this method is marked as deprecated and starts with <code>impl_</code>. The combination of these two markings are how the JavaFX team tells us that this method will change and break in unexpected ways. But I think we are safe for JavaFX 2.2.x.</p>


<p>In this method simply return all of the <code>StyleableProperty</code> objects that you want the CSS engine to set and alter. Remember, this is all of the properties, including the properties of the parent class. So be sure you return those (unless you explicitly want to hide them). You can be a good software engineer and use a lazy cache if you like. It will perform (slightly) better.</p>


<div><script src='https://gist.github.com/3711714.js?file=StyleableProperty3.java'></script>
<noscript><pre><code>    private static List&lt;StyleableProperty&gt; STYLEABLES;

    @Override
    @Deprecated
    public List&lt;StyleableProperty&gt; impl_getStyleableProperties() {
        if (STYLEABLES == null) {
            final List&lt;StyleableProperty&gt; styleables = new ArrayList&lt;StyleableProperty&gt;(super.impl_getStyleableProperties());
            Collections.addAll(styleables,
                    BACK_ANGLE,
                    BACK_OFFSET,
                    BACK_SCALE,
                    BACK_SPACING);
            STYLEABLES = Collections.unmodifiableList(styleables);
        }
        return STYLEABLES;    //To change body of overridden methods use File | Settings | File Templates.
    }
</code></pre></noscript></div>




<p><strong>The Proof is in the Pudding</strong></p>


<p>I am sure I violated some coding standards the JavaFX team uses to create their CSS properties, but at the end of the day the code works. I do have to say, there is quite a bit of Yak Shaving that goes on. Hopefully in JavaFX 8 they will come up with some amazingly simple means to mark properties as styleable (I have <a href="https://gist.github.com/3711882">some ideas</a>). But until that future day, you can do CSS styling on your custom controls now.</p>

]]></content>
  </entry>
  
</feed>
