<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: JavaFX | ...and they shall know me by my speling errors.]]></title>
  <link href="http://speling.shemnon.com//blog/categories/javafx/atom.xml" rel="self"/>
  <link href="http://speling.shemnon.com//"/>
  <updated>2013-06-08T18:05:47-06:00</updated>
  <id>http://speling.shemnon.com//</id>
  <author>
    <name><![CDATA[Danno Ferrin]]></name>
    <email><![CDATA[danno.ferrin@shemnon.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Gradle JavaFX Plugin 0.2.0 Released]]></title>
    <link href="http://speling.shemnon.com//blog/2013/01/30/gradle-javafx-plugin-0-dot-2-0-released/"/>
    <updated>2013-01-30T19:57:00-07:00</updated>
    <id>http://speling.shemnon.com//blog/2013/01/30/gradle-javafx-plugin-0-dot-2-0-released</id>
    <content type="html"><![CDATA[<p>The 0.2.0 release of the Gradle JavaFX Plugin is now live on <a href="http://l.aunch.us/fOjm">BinTray</a>. Get it while it's hot! More things changed in this release than the lat time around. First there has been a lot of work automating the use of icons in the packaged resource. My <a href="http://speling.shemnon.com/blog/2013/01/28/adding-icons-with-the-gradle-javafx-plugin/">previous post</a> has all the details. Second, the interaction between the Maven and Eclipse plugin has been improved. Finally, the distribution has move to BinTray for the release artifacts.</p>

<!-- more -->


<p><strong>Changed Conventions</strong></p>

<p>There is one notable change that needs to be called out. Previously package specific resources went under <code>src/main/resources</code>. I have moved them to <code>src/deploy/resources</code> to clarify that they are used for deployment and not at runtime. This was needed for the gradle eclipse plugin to create sensible projects. The sample applications have been adjusted appropriately.</p>

<p><strong>Changed Deployment Info</strong></p>

<p>The plugin is no longer deployed to the webdav repository on CloudBees, but instead has migrated over to <a href="http://l.aunch.us/fOjm">BinTray</a>. The new recommend release scripts for the most recent version of the plugin, regardless of version:</p>

<p><code>
apply from: 'http://dl.bintray.com/content/shemnon/javafx-gradle/javafx.plugin'
</code></p>

<p>For a version locked script you can use this script</p>

<p><code>
apply from: 'http://dl.bintray.com/content/shemnon/javafx-gradle/0.2.0/javafx.plugin'
</code></p>

<p>The repository location and co-ordinates also have changed. If you are using a direct build script dependency you will to use this co-ordinate</p>

<p><code>
org.bitbucket.shemnon.javafxplugin:gradle-javafx-plugin:0.2.0
</code></p>

<p>You will likely want to look at the <a href="http://dl.bintray.com/content/shemnon/javafx-gradle/0.2.0/javafx.plugin">apply script</a> anyway since there are also some other build time dependencies. <em>I wish gradle just had a way to apply plugins from a maven co-ordinate, with dependencies.</em></p>

<p><strong> Examples </strong></p>

<p>If you would like to see some samples built with the plugin you can download them from <a href="http://repository-javafx-gradle-plugin.forge.cloudbees.com/release/0.2.0/">the CloudBees repository</a>. Only the single file installers are available. The <a href="https://bitbucket.org/shemnon/javafx-gradle/src/009e6d4d2487/samples?at=release_0.2.0">source</a> is available at the <a href="https://bitbucket.org/shemnon/javafx-gradle/">bitbucket project</a>.</p>

<p><strong> Future Plans </strong></p>

<p>For the next release I am planning on spending more time focusing on making the per-platform packaging top notch. I will add in hooks and allowances so that the end user can build any of the packaged platforms without conflict. One example is that the <code>appId</code> means different, incompatible, things on Windows and Mac. Windows wants a GUID whereas Mac wants a CFBundleIdentifier (which is close to a package name). Then there is the issue of gatekeeper and other smaller details.</p>

<p>In the mean time, if you find any bugs please be sure to <a href="https://bitbucket.org/shemnon/javafx-gradle/issues?status=new&amp;status=open">report them</a>. I can also be found on twitter as <a href="http://twitter.com/shemnon">@shemnon</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Adding Icons with the Gradle JavaFX Plugin]]></title>
    <link href="http://speling.shemnon.com//blog/2013/01/28/adding-icons-with-the-gradle-javafx-plugin/"/>
    <updated>2013-01-28T14:57:00-07:00</updated>
    <id>http://speling.shemnon.com//blog/2013/01/28/adding-icons-with-the-gradle-javafx-plugin</id>
    <content type="html"><![CDATA[<p>The 0.2.0 release of the Gradle JavaFX Plugin is just around the corner. I want to spend some time building all the samples on all of the platforms and making sure smoke doesn't come out. Expect it in a day or two.</p>

<p>The major feature for this release is better handling of packaged icons across the platforms. There is a file convention manner and a build script configuration method that will allow you to take a set of PNG images and let the build tool create the needed specialty file for each platform.</p>

<!-- more -->


<p>A quick word of warning before I dive into the details. You have to choose either the convention or the configuration, not both. If you do any configuration of your icons then none of the file conventions will be applied.</p>

<p><strong> Icons By Convention </strong></p>

<p>The easiest method is just to place specifically named icons in a specific place. The directory you should place the icons in is <code>src/deploy/package</code>. The icons also all need to be PNG images. The real magic is in how you name your icons. If they have the right pattern for their name then icon will be used and the sizes and other metadata are calculated by the plugin.</p>

<p>When naming icons for the conventional method the first part of the name describes the role of the icon. Right now the values are <code>shortcut</code>, <code>volume</code>, and <code>setup</code>. An icon of type <code>shortcut</code> will be the icon in the launcher, executable, taskbar, menu, or dock. An icon of type <code>volume</code> will be used for the MacOSX DMG folder icon. And an icon of type <code>setup</code> will appear in the corner of a Windows EXE setup wizard.</p>

<p>The second part of the name is any random set of characters. You would do this to distinguish the various sizes of the icons. However multiple icons are only recommend for the <code>shortcut</code> and <code>volume</code> icon sets, since the <code>setup</code> icon is converted into a BMP by the plugin. For MacOSX you also need to pay attention to the icon sizes, since only certain sizes are used by the MacOSX ICNS file. Those size are 16, 32, 128, 256, and 512 square. Note that 64x64 is not in that list!</p>

<p>The final part of the name is only relevant to MacOSX installers. If the file has '@2x' in it's name anywhere, it is presumed to be a HDPI icon for that size. This means that the pixel dimensions are twice as large for that icon then the size it is considered to be. Right now the string can occur anywhere, but future versions of the plugin may require it to be at the end of the name.</p>

<p>For example, a 16x16 icon named <code>shortcut.png</code> would be used as the shortcut icon. If there was another 512x512 icon named <code>shortcut-awesome.png</code> that icon would be used as well. And if a 1024x1024 icon was also in the correct directory and it was named <code>shortcutReallyAwesome@2x.png</code> then it would be a shortcut icon, at HDPI scale 2, used for the 512x512 icon. For a functional example of this see the <a href="https://bitbucket.org/shemnon/javafx-gradle/src/1bd371c2d4656d383636f84a37a5841e6894af23/samples/brickbreaker/src/deploy/package?at=master">brickbreaker</a> sample in the source code.</p>

<p><strong>Icons by Configuration</strong></p>

<p>If you want to have the build script configure the icons you can do that as well. This will allow the re-use of icons across different usage kinds. There are two methods of configuration both of which are supported when using the configuration option.</p>

<p>The shorthand method involved adding an <code>icons</code> configuration setting inside the <code>javafx</code> configuration setting. Inside this configuration you set a value for each kind of icon you are using to either a string or list of strings. These strings will be resolved as files against the <code>src/deploy/package</code> directory. For example, from the <a href="https://bitbucket.org/shemnon/javafx-gradle/src/1bd371c2d465/samples/FullyExpressed/build.gradle?at=master#cl-92">FullyExpressed</a> sample (which is a junk project that turns every knob and flips every switch just to do it) the icons are configured like this:</p>

<p>```
javafx {</p>

<pre><code>/*. . . snip . . .*/
icons {
    shortcut = ['shortcut-16.png', 'shortcut-32.png', 
                'shortcut-128.png', 'shortcut-256.png', 
                'shortcut-16@2x.png', 'shortcut-32@2x.png', 
                'shortcut-128@2x.png']
    volume = 'javafx-icon.png'
    setup = 'javafx-icon.png'
}
/*. . . snip . . .*/
</code></pre>

<p>}
```</p>

<p>Like the conventional way the sizes of the icons are sniffed out and the HDPI icons all contain '@2x' at the end of their name. The icons also all must be PNG icons. Finally, remember that any text between the kind and the possible end of the name is not used by the plugin, unless it is the <code>@2x</code> at the end to tell the icon it is a HDPI icon.</p>

<p>If you need total control over the JNLP descriptor you can specify each one in an <code>icon</code> setting. You repeat the setting for each icon. You can then set each attribute individually. For example, form the same <a href="https://bitbucket.org/shemnon/javafx-gradle/src/bbe9d6ebe08d/samples/FullyExpressed/build.gradle?at=master#cl-99">FullyExpressed</a> sample the splash and selected icons are configured manually.</p>

<p>```
javafx {</p>

<pre><code>/*. . . snip . . .*/
icon {
    href = 'src/main/resources/javafx-icon.png'
    kind = 'splash'
    width = 128
    height = 128
}
icon {
    href = 'shortcut-32@2x.png'
    kind = 'selected'
    width = 16
    height = 16
    scale = 1
}
/*. . . snip . . .*/
</code></pre>

<p>}
```</p>

<p><strong>Packager Defaults</strong></p>

<p>The defaults provided buy the JavaFX packaging library were not changed.  So if you see a grey embossed java coffee cup then the default for that icon has not been changed.</p>

<p>If you want to use the current code, you can add <code>apply from: 'https://repository-javafx-gradle-plugin.forge.cloudbees.com/snapshot/javafx.plugin</code> to the top of your gradle file.  Or you can wait a few days until I push the bits to BinTray.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mirroring OpenJFX on BitBucket, an Update]]></title>
    <link href="http://speling.shemnon.com//blog/2012/12/20/mirroring-openjfx-on-bitbucket-an-update/"/>
    <updated>2012-12-20T20:18:00-07:00</updated>
    <id>http://speling.shemnon.com//blog/2012/12/20/mirroring-openjfx-on-bitbucket-an-update</id>
    <content type="html"><![CDATA[<p>This is a quick update on my mirrors of OpenJFX on BitBucket.  I've moved some stuff around and automated it a bit.  I am also retiring my "combined" repo that would merge the master, graphics, and controls scrums together.  It got messy with multiple heads and bookmarks, and given the weekly merging the two scrums do wasn't really adding any value.</p>

<!-- more -->


<p><strong>Updates on Names</strong></p>

<p>The first major change that I did was to move the mirrors off of my personal account onto a team account named <a href="https://bitbucket.org/openjfxmirrors">'OpenJFX Mirrors'</a>.  That landing page is kind of ugly, so I created a repo to hold a wiki whose only page right now <a href="https://bitbucket.org/openjfxmirrors/mirrors/wiki/Home">describes the current mirrors</a>.</p>

<p>One advantage of the name change is that it allows for more participation.  On the free bitbucket account up to 4 other people can be added in to manage things.  There is also the marketing advantage of saying the BitBucket "team" is dedicated to mirroring OpenJFX, and that it is more than one of my many repos on BitBucket (I have many private repos).</p>

<p>There is a standard mapping of the OpenJDK repos to the BitBucket repos.  Basically you change the prefix and then replaces slashes with dashes.  For example this URL:</p>

<pre><code>https://hg.openjdk.java.net/openjfx/8/controls/rt
</code></pre>

<p>is mirrored to this URL:</p>

<pre><code>https://bitbucket.org/openjfxmirrors/openjfx-8-controls-rt
</code></pre>

<p>It is important to note that not every OpenJFX Repo is mirrored.  Right now I only mirror the Version 8 branches.  Of the 2.x line I only consider 2.2.6 to be worthy of mirroring, and then since it is just bug fixes and not feature adds I consider it less interesting.</p>

<p><strong>Automation</strong></p>

<p>The second major change is that I have automated the update of the repos.  Before I had a shell script on my MacBook Air that would do the pulling and pushing of the repo data.  It was slick and easy, but it required me opening up my Macbook air once in a while.  At my old job it was a more than daily occurrence.  But since I am starting up new work at Fluke Networks I have more interesting things to do all day than keeping up to date on all of Reddit's Advice Animals.</p>

<p>Writing this script is incredibly simple.  At the core of the loop are the two real commands that get work done:</p>

<pre><code>hg pull
hg push
</code></pre>

<p>That's all.  And I am not just pushing the repo back onto itself.  Mercurial comes with the concept of a <em>default push</em> repository.  Pulls come from the default, and pushes by default go to the default push repo, or just the default repo if not set.  The <code>.hg/hgrc</code> file contains this mapping:</p>

<pre><code>[paths]
default = http://hg.openjdk.java.net/openjfx/8/controls/rt
default-push = ssh://hg@bitbucket.org/openjfxmirrors/openjfx-8-controls-rt
</code></pre>

<p>Of note is that I use the SSH mapping with a public key so the script is never asked for my user password and never knows about it to begin with.</p>

<p><strong>Props to CloudBees and Atlassian</strong></p>

<p>None of this would have been possible without the gracious donation of disk space and processing time from two names you should already know.  Atlassian and CloudBees.</p>

<p><a href="http://www.atlassian.com/">Atlassian</a> owns and operates the <a href="https://bitbucket.org/">BitBucket</a> service, which hosts the Mercurial repositories that I am using to mirror.  The point of this mirroring is that the UI at BitBucket is orders of magnitude better than the one you get at OpenJDK.  Visualizing the changes and examining the source files is actually possible with this interface.</p>

<p>The automation is hosted over at <a href="http://www.cloudbees.com/">CloudBees</a> on their eponymous cloud build platform. It is awesome of them to offer free build server time to open source projects.  I even have one of their technical running shirts I snagged at JavaOne this year.  (And I promise it will get more use as a running shirt next year).</p>

<p>Give these companies some of your business, they deserve it.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TextFlow for Fun and Profit]]></title>
    <link href="http://speling.shemnon.com//blog/2012/12/10/textflow-for-fun-and-profit/"/>
    <updated>2012-12-10T21:10:00-07:00</updated>
    <id>http://speling.shemnon.com//blog/2012/12/10/textflow-for-fun-and-profit</id>
    <content type="html"><![CDATA[<p>One of the newer features for JavaFX is the new <a href="https://wikis.oracle.com/display/OpenJDK/Rich+Text+API+Samples">TextFlow</a> node.  Revealed at JavaOne San Francisco this is the generel solution to a rich text component in JavaFX.</p>

<p>This also happens to fit in nicely with my planned hobby project for the next few months.  The deck control was one part, and the ability to take MarkDown into a JavaFX node is another important part of the equation.  To prototype this I wrote a little toy app I call <a href="https://bitbucket.org/shemnon/flowdown">FlowDown</a></p>

<!-- more -->


<p><strong>FlowPane turns the corner</strong></p>

<p>TextFlow at it's core is a lot like <a href="http://docs.oracle.com/javafx/2/api/index.html?javafx/scene/layout/FlowPane.html">FlowPane</a>.  The children are laid out in order from the leading edge to the training edge.  When it reaches the edge of the component it goes to the next row and continues to lay out it's children.  What is different about TextFlow is that if the next child is a Text node it will fit as much of it as it can in the current row, and then take the remainder to the next row. And if needed it will flow the content across multiple rows to fit the constrained width.  So large long paragraphs of text now take only one node, whereas before you had to resort to tricks that essentially created one node per word.</p>

<p><img src="/images/FlowDown.png" alt="FlowDown in action" /></p>

<p><strong>Caution: Beta Code Ahead</strong></p>

<p>To use this toy app you will need one of the more current builds of <a href="http://jdk8.java.net/download.html">JDK8</a> newer than build 66 (build 67 was the current one as of this post).  But this is an early access build which means you cannot distribute it and other things may be broken (like copy and paste on OSX).</p>

<p>The markdown previewer itself is also beta.  Problems include ordered lists not being numbered, and list layout in general being wonky.  Feel free to <a href="https://bitbucket.org/shemnon/flowdown/issues?status=new&amp;status=open">post issues</a>.  Since markdown to JFX nodes is something that may be generally useful I do see myself making a component out of.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Scenic View in the Gradle JavaFX Plugin]]></title>
    <link href="http://speling.shemnon.com//blog/2012/11/25/scenic-view-in-the-gradle-plugin/"/>
    <updated>2012-11-25T13:42:00-07:00</updated>
    <id>http://speling.shemnon.com//blog/2012/11/25/scenic-view-in-the-gradle-plugin</id>
    <content type="html"><![CDATA[<p>While I really like the <a href="http://fxexperience.com/scenic-view/">Scenic View</a> application that Jasper, Richard, and Jonathan have put together I do have to say getting it working is a bit of a struggle.  But like most things I wind up blogging about this is something that can be fixed with a little bit of magical Gradle dust.</p>

<!-- more -->


<p><strong>Skinning the Cat</strong></p>

<p>Getting Scenic view to work shouldn't be a struggle since there are three ways to start it up.  Well the fact there are three ways may be part of the problem actually.  The first is to rely on auto-discovery.  This is the same thing that JVisualVM relies on.  However this doesn't work for me since I do my personal hacking on a MacBook Air, and the auto-discovery isn't as reliable as it is on Windows machines.  I.e. you get the mac experience of it 'just working' on windows but no mac.  To be fair, this is option number three on the list and they openly admit it's not the best choice currently.</p>

<p>Another option is to bundle in the jar and explicitly start the scenic view.  The code is incredibly terse and has no real dependencies on your application code, except that the code needs to be run and the node to view.  The downside here is that you always need the code available to compile and you always need the line in your code.  You can hide the invocation with bear-claw clicks and keystrokes but the burden remains on you to either properly hide it or strip the code before you publish.</p>

<p>The last option, and the preferable one according to the docs, is to add the scenic view code as a java agent to your JVM.  This is very reliable method but it has a very specific incantation you need to add to your launch command.  And to add on to the troubles, there is no standard place this jar files live, it lives where you drop it.  And old man Murphy says that you cannot depend on others placing it in the same place, unless you do it for them.</p>

<p><strong>Integrations with Gradle</strong></p>

<p>The first problem is that this program is not released into Maven Central.  With gradle we can punt on running a maven repository and just upload it to an ivy repository.  In this case I am doubling up with the <a href="https://repository-javafx-gradle-plugin.forge.cloudbees.com/release/">Gradle JavaFX Plugin</a> repository.  Unlike the FXExperience Tools the code isn't in a public repo so I cannot guess the license.  I'll err on the side of sharing.</p>

<p>The next problem is getting the jar local.  I tried several approaches.  I don't need the jar at build time for the plugin.  And adding it to the plugin dependencies creates some unneeded weirdness for application build scripts.  Finally what I settled on was to dynamically alter the gradle script via the DSL.  As <a href="https://bitbucket.org/shemnon/javafx-gradle/changeset/4dd2ff67e69410802306948ef097caf4#Lplugin/src/main/groovy/com/bitbucket/shemnon/javafxplugin/JavaFXPlugin.groovyT233">part of the task</a> I create a new configuration, add a new repository, and add a dependency to that configuration,  Then I find all the tasks that are considered execution tasks and I prepend the needed agent string with the local cached copy of the scenic view jar.  Did you catch and understand all of that?  Don't worry, you don't need to understand the magic to use it.</p>

<p>This task will be part of the next release of the plugin.  If you are using the snapshot script you already have it.</p>

<p><strong>Too Long; Didn't Read</strong></p>

<p>To use scenic view with the gradle plugin just add the task <code>scenicview</code> before your execution task.  Really you have two options.  If you are not attaching a debugger:</p>

<pre><code>gradle scenicview run
</code></pre>

<p>if you are attaching a debugger:</p>

<pre><code>gradle scenicview debug
</code></pre>

<p>There will be no random jars added into your released code as long as you stick with the above incantations.  And it will magically work.</p>
]]></content>
  </entry>
  
</feed>
