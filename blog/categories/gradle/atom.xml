<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Gradle | ...and they shall know me by my speling errors.]]></title>
  <link href="http://speling.shemnon.com//blog/categories/gradle/atom.xml" rel="self"/>
  <link href="http://speling.shemnon.com//"/>
  <updated>2012-10-23T22:16:28-06:00</updated>
  <id>http://speling.shemnon.com//</id>
  <author>
    <name><![CDATA[Danno Ferrin]]></name>
    <email><![CDATA[danno.ferrin@shemnon.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Conventions and Configuratons]]></title>
    <link href="http://speling.shemnon.com//blog/2012/10/23/conventions-and-configurations/"/>
    <updated>2012-10-23T22:13:00-06:00</updated>
    <id>http://speling.shemnon.com//blog/2012/10/23/conventions-and-configurations</id>
    <content type="html"><![CDATA[<p>Creating an app in any new framework can sometimes be a bit of a chore.  Have you looked at the files that come form a new Hello World JavaFX app from NetBeans?  Not very dry at all and a lot of esoteric stuff in side directories is created, you know just in case you want to customize it.  And the problem isn't NetBeans, they are doing the best they can with Ant.</p>

<p><strong>The Ideal Build</strong></p>

<p>To me the ideal build setup for a JavaFX application would involve putting your source files in a specific directory layout, placing supporting files in a similarly conventional manner, adding a <em>minimal</em> build script, pressing a button, and catching my .app or .exe as it falls out the other side.</p>

<!-- more -->


<p>One of the keys here is the minimal build script.  If I am doing things the standard way then my actions should be presumed.  Presumed without comment.  Part of the legacy of the <a href="http://ant.apache.org/">ant</a> build system is you cannot simply say 'my Java code is here, make a jar.'  You have to hand walk the build from where your source code lives, to where you want the compiled class files to go, to where you want the jar to go, to what you want to name it.  And heaven forbid if you use other peoples libraries, or expect other people to use yours.</p>

<p>I'm being a little harsh on Ant here. Let's roll back our memory to 13 years ago and realize how Ant was eight kinds of awesome compared to a <a href="http://www.gnu.org/software/make/manual/make.html">make</a> file.  Many builds I saw used to drop class files in the source tree.  And if you had to add a package you either had to update the make file or hope some side voodoo script could sniff it out, and the mess leftover was barely tolerable.  Recursive file sniffing and a separate build directories were the gold standard back at the turn of the century.  But the problem with higher standards is eventually they become the baseline expectation.  Consider how much building software stunk before even make existed!</p>

<p><strong>Hand Cranked to Configurable to Conventional</strong></p>

<p>The evolution we are witnessing here is one of increased automation, and the standardization.  This is just like the industrial revolution and the classic example of firearms.  You can hand craft a rife, and it will work just fine.  If anything breaks, however, you have to hand craft a replacement and often craft other pieces to make sure it continues to work.  When the parts were standardized, in both assembly and interface, you can mass produce many different rifles and do many interesting things with the various add ons.  If you want a slightly different grip or trigger, you can replace it because if the interface.  If you find a broken rifle you can figure out what is wrong with it because of the standard assembly,  And if you stick to the standards, ammunition is readily interchangeable between any rifle.</p>

<p>One of the key issues with interchangeable parts, however, is the need for a critical mass.  With a small audience conventions are merely incidental.  In large groups and with enough adoption they become the rules of society, for example what side you pass someone on the sidewalk.</p>

<p><strong>File Conventions</strong></p>

<p>To take us closer to the industrialized build we need to agree on some conventions. Even though I am building a Gradle plugin, I feel we need to accept and adopt widely some Maven conventions.  Specifically the <code>src/&lt;set&gt;/&lt;language|role&gt;/...</code> pattern for source files.  Gradle already adopts this pattern by default, which is good from the viewpoint of interchangeable parts.</p>

<pre><code>&lt;root&gt;/
+--src/
   +--main/
      +--java/
      |  +--&lt;Java Classes by package&gt;
      +--resources/
      |  +--&lt;Resources, like CSS and image, by package&gt;
      +--package/
         +--win/
         |  +--&lt;Bundle specific files&gt;
         +--macosx/
         |  +--&lt;Bundle specific files&gt;
         +--linux/
         |  +--&lt;Bundle specific files&gt;
         +--&lt;icon files for bundles&gt;
</code></pre>

<p>This is notional, and I am more than willing to hear comments as to where I am getting stuff wrong.  This is currently the file layout I am using for my Gradle JavaFX plugin, and I've pulled three of the JavaFX sample apps into this directory format, and the build files are all quite short (after the yak shaving to install the plugin).  <a href="https://bitbucket.org/shemnon/javafx-gradle/src/c52be485c341796394ae9c7ba9d44f1d79c45889/samples/brickbreaker/build.gradle?at=master">Brickbreaker</a> just installs the plugin.  <a href="https://bitbucket.org/shemnon/javafx-gradle/src/c52be485c341/samples/ConferenceScheduleApp/build.gradle?at=master">ConferenceScheduleApp</a> only names the executable (with bonus Java Version yak shaving) while <a href="https://bitbucket.org/shemnon/javafx-gradle/src/c52be485c341/samples/Ensemble2/build.gradle?at=master">Ensemble2</a> has the most to do, and none of it involved JavaFX but it is peculiar to how the app works.</p>

<p>My goal here, is to make all of the JavaFX yak shaving transparent, so you can focus on indexing your samples in your build rather than remembering the syntax of the ant deploy task.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Starting a JavaFX Gradle Plugin]]></title>
    <link href="http://speling.shemnon.com//blog/2012/10/17/javafx-gradle-plugin/"/>
    <updated>2012-10-17T22:47:00-06:00</updated>
    <id>http://speling.shemnon.com//blog/2012/10/17/javafx-gradle-plugin</id>
    <content type="html"><![CDATA[<p>I wanted to get this out there early, since "release early release often" is one of the open source mantras.  I have a longer blog post planned on this subject, but I have so many balls in the air right now I'm not sure when I'll get to write it.</p>

<p>I am starting to write a <a href="https://bitbucket.org/shemnon/javafx-gradle">JavaFX 2.0 Gradle Plugin</a> over at bitbucket.  Right now it handles just the <code>fx:jar</code> and <code>fx:deploy</code> ant tasks.  And not completely. I don't have the resources wired into the native bundles.  But that will come.  I also am not doing binary CSS or Jar signing.</p>

<!-- more -->


<p>There are two samples in the repo demonstrating the build.  I pulled from the JavaFX 2.2.0 Samples brickbreaker and Ensemble2 which represents a small and large project. I moved the files around into a conventional layout, and provided the barest of Gradle scripts I could, with the help of the plugin.  The script for <a href="https://bitbucket.org/shemnon/javafx-gradle/src/4f1f197a845d5fccc4408ad3c49167e65421b1df/brickbreaker/build.gradle?at=master">brickbreaker</a> is awesomely short.  And <a href="https://bitbucket.org/shemnon/javafx-gradle/src/955cc9b99dc86c3b384b40157801ffd3c1adfe94/Ensemble2/build.gradle?at=master">Ensemble2</a> is a bit longer because of the custom build work it is doing to bring the source of the samples into the jar.  When you run 'gradle assemble` it will actually create the Mac OSX .app and .dmg files.  It probably does the correct thing on Linux and Windows but I haven't tried yet.  But first you need to install the plugin via 'gradle install' in the plugin dir.</p>

<p><strong>Conventions</strong></p>

<p>My main purpose in this exercise is to try and nail down a set of file layout conventions that Gradle and Maven can use to create a shippable app with a minimum of configuration.  Layouts that match the Maven way for the most part.  And Ant scripts can be written to these conventions.  If, you know, Ant is your thing.</p>

<p>The only out there conventions would be the bundle resources, which I am placing in <code>src/main/resources</code>.  I also intend to add some other standard files, like <code>src/main/resources/icon.png</code> and associated files and directories being loaded into the proper place for native bundling.  I also need to figure out what to do about signing keys.  Likely this will have to be a configuration thing since checking in your signing key to source control would be a bad idea, even if you have the world's most awesome password.</p>

<p>Finally, I have zero intention of writing this hypothetical Maven plugin. Gradle is what I do for fun. I'de rather write Perl scripts than Maven plugins, no offense to the Perl crowd. But being part of the conversation to set the conventions is something I intend to be a part of.</p>
]]></content>
  </entry>
  
</feed>
